# 可行性报告

- [可行性报告](#%e5%8f%af%e8%a1%8c%e6%80%a7%e6%8a%a5%e5%91%8a)
  - [摘要](#%e6%91%98%e8%a6%81)
  - [实现方案与可行性分析](#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88%e4%b8%8e%e5%8f%af%e8%a1%8c%e6%80%a7%e5%88%86%e6%9e%90)
    - [项目结构](#%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84)
    - [客户端](#%e5%ae%a2%e6%88%b7%e7%ab%af)
      - [介绍](#%e4%bb%8b%e7%bb%8d)
      - [结构](#%e7%bb%93%e6%9e%84)
      - [特性](#%e7%89%b9%e6%80%a7)
      - [功能](#%e5%8a%9f%e8%83%bd)
        - [获取本地目录](#%e8%8e%b7%e5%8f%96%e6%9c%ac%e5%9c%b0%e7%9b%ae%e5%bd%95)
        - [对文件进行分块](#%e5%af%b9%e6%96%87%e4%bb%b6%e8%bf%9b%e8%a1%8c%e5%88%86%e5%9d%97)
        - [与服务器交换碎片](#%e4%b8%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%ba%a4%e6%8d%a2%e7%a2%8e%e7%89%87)
        - [响应服务器删除本地文件](#%e5%93%8d%e5%ba%94%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%88%a0%e9%99%a4%e6%9c%ac%e5%9c%b0%e6%96%87%e4%bb%b6)
    - [服务器](#%e6%9c%8d%e5%8a%a1%e5%99%a8)
      - [介绍](#%e4%bb%8b%e7%bb%8d-1)
      - [结构](#%e7%bb%93%e6%9e%84-1)
      - [特性](#%e7%89%b9%e6%80%a7-1)
      - [功能](#%e5%8a%9f%e8%83%bd-1)
        - [接收、回复、转发服务请求与控制信息](#%e6%8e%a5%e6%94%b6%e5%9b%9e%e5%a4%8d%e8%bd%ac%e5%8f%91%e6%9c%8d%e5%8a%a1%e8%af%b7%e6%b1%82%e4%b8%8e%e6%8e%a7%e5%88%b6%e4%bf%a1%e6%81%af)
        - [转发数据](#%e8%bd%ac%e5%8f%91%e6%95%b0%e6%8d%ae)
        - [分离数据链接与控制链接](#%e5%88%86%e7%a6%bb%e6%95%b0%e6%8d%ae%e9%93%be%e6%8e%a5%e4%b8%8e%e6%8e%a7%e5%88%b6%e9%93%be%e6%8e%a5)
        - [维护文件索引](#%e7%bb%b4%e6%8a%a4%e6%96%87%e4%bb%b6%e7%b4%a2%e5%bc%95)
        - [维护各个客户端的状态信息](#%e7%bb%b4%e6%8a%a4%e5%90%84%e4%b8%aa%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af)
        - [记录、处理当前等待响应的文件请求](#%e8%ae%b0%e5%bd%95%e5%a4%84%e7%90%86%e5%bd%93%e5%89%8d%e7%ad%89%e5%be%85%e5%93%8d%e5%ba%94%e7%9a%84%e6%96%87%e4%bb%b6%e8%af%b7%e6%b1%82)
    - [浏览器端](#%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af)
      - [网页使用 JavaScript](#%e7%bd%91%e9%a1%b5%e4%bd%bf%e7%94%a8-javascript)
      - [使用 JavaScript 时包含 JQuery 库](#%e4%bd%bf%e7%94%a8-javascript-%e6%97%b6%e5%8c%85%e5%90%ab-jquery-%e5%ba%93)
      - [网页 UI 设计采用 Bootstrap 框架](#%e7%bd%91%e9%a1%b5-ui-%e8%ae%be%e8%ae%a1%e9%87%87%e7%94%a8-bootstrap-%e6%a1%86%e6%9e%b6)
      - [网页和服务器的交互采用 AJAX](#%e7%bd%91%e9%a1%b5%e5%92%8c%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%ba%a4%e4%ba%92%e9%87%87%e7%94%a8-ajax)
      - [通讯格式](#%e9%80%9a%e8%ae%af%e6%a0%bc%e5%bc%8f)
      - [Apache+Tomcat+Servlet+Java Web 应用](#apachetomcatservletjava-web-%e5%ba%94%e7%94%a8)
      - [动态网页设计](#%e5%8a%a8%e6%80%81%e7%bd%91%e9%a1%b5%e8%ae%be%e8%ae%a1)
    - [纠删码](#%e7%ba%a0%e5%88%a0%e7%a0%81)
      - [介绍](#%e4%bb%8b%e7%bb%8d-2)
      - [GitHub 上现有的项目](#github-%e4%b8%8a%e7%8e%b0%e6%9c%89%e7%9a%84%e9%a1%b9%e7%9b%ae)
    - [WebAssembly](#webassembly)
    - [容器化](#%e5%ae%b9%e5%99%a8%e5%8c%96)
    - [虚拟局域网](#%e8%99%9a%e6%8b%9f%e5%b1%80%e5%9f%9f%e7%bd%91)
  - [理论依据与技术依据](#%e7%90%86%e8%ae%ba%e4%be%9d%e6%8d%ae%e4%b8%8e%e6%8a%80%e6%9c%af%e4%be%9d%e6%8d%ae)
      - [用 Vandermonde Code 编码及解码文件](#%e7%94%a8-vandermonde-code-%e7%bc%96%e7%a0%81%e5%8f%8a%e8%a7%a3%e7%a0%81%e6%96%87%e4%bb%b6)
        - [RS code编码原理](#rs-code%e7%bc%96%e7%a0%81%e5%8e%9f%e7%90%86)
        - [RS code 编码数据恢复原理](#rs-code-%e7%bc%96%e7%a0%81%e6%95%b0%e6%8d%ae%e6%81%a2%e5%a4%8d%e5%8e%9f%e7%90%86)
        - [RS code 编码的限制](#rs-code-%e7%bc%96%e7%a0%81%e7%9a%84%e9%99%90%e5%88%b6)
        - [编码矩阵基于范德蒙德（Vandermonde）矩阵](#%e7%bc%96%e7%a0%81%e7%9f%a9%e9%98%b5%e5%9f%ba%e4%ba%8e%e8%8c%83%e5%be%b7%e8%92%99%e5%be%b7vandermonde%e7%9f%a9%e9%98%b5)
        - [编码矩阵基于柯西（Cauchy）矩阵](#%e7%bc%96%e7%a0%81%e7%9f%a9%e9%98%b5%e5%9f%ba%e4%ba%8e%e6%9f%af%e8%a5%bfcauchy%e7%9f%a9%e9%98%b5)
    - [JVM](#jvm)
  - [创新点](#%e5%88%9b%e6%96%b0%e7%82%b9)
    - [备份机制：Erasure Code](#%e5%a4%87%e4%bb%bd%e6%9c%ba%e5%88%b6erasure-code)
    - [可用性：结合对等主机与网盘服务](#%e5%8f%af%e7%94%a8%e6%80%a7%e7%bb%93%e5%90%88%e5%af%b9%e7%ad%89%e4%b8%bb%e6%9c%ba%e4%b8%8e%e7%bd%91%e7%9b%98%e6%9c%8d%e5%8a%a1)
    - [用户访问](#%e7%94%a8%e6%88%b7%e8%ae%bf%e9%97%ae)
    - [客户端部署](#%e5%ae%a2%e6%88%b7%e7%ab%af%e9%83%a8%e7%bd%b2)
    - [容器化部署服务端](#%e5%ae%b9%e5%99%a8%e5%8c%96%e9%83%a8%e7%bd%b2%e6%9c%8d%e5%8a%a1%e7%ab%af)
    - [跨平台](#%e8%b7%a8%e5%b9%b3%e5%8f%b0)
    - [erasure code 冗余备份](#erasure-code-%e5%86%97%e4%bd%99%e5%a4%87%e4%bb%bd)
    - [加入多用户权限支持](#%e5%8a%a0%e5%85%a5%e5%a4%9a%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90%e6%94%af%e6%8c%81)
    - [更高效的文件处理和传输](#%e6%9b%b4%e9%ab%98%e6%95%88%e7%9a%84%e6%96%87%e4%bb%b6%e5%a4%84%e7%90%86%e5%92%8c%e4%bc%a0%e8%be%93)
    - [提高文件安全性](#%e6%8f%90%e9%ab%98%e6%96%87%e4%bb%b6%e5%ae%89%e5%85%a8%e6%80%a7)
    - [提高服务可用性](#%e6%8f%90%e9%ab%98%e6%9c%8d%e5%8a%a1%e5%8f%af%e7%94%a8%e6%80%a7)
  - [#附录 1 相关调研](#%e9%99%84%e5%bd%95-1-%e7%9b%b8%e5%85%b3%e8%b0%83%e7%a0%94)
  - [相关工作（科研及工业界）](#%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c%e7%a7%91%e7%a0%94%e5%8f%8a%e5%b7%a5%e4%b8%9a%e7%95%8c)
  - [参考文献](#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae)

## 摘要

## 实现方案与可行性分析

TODO-yzy：分别阐述各个模块的设计与初步实现方案，并讨论可行性。为了方便借鉴成文，用#表示前辈组的报告的框架（可能稍有修改），其中有些功能是在我们的方案中改进了的，可能去掉了可能没有。下面用//TODO表示前期调研的重点，TODO-yzy表示一点意见

### 项目结构

TODO-yzy：在这里也许可以以图片形式简单描绘一下架构。

### 客户端

TODO-yzy：客户端等的简介，可以简单介绍功能，描绘结构，介绍可能实现的特性，然后罗列具体功能及实现方案（如部分代码、现有的可用的项目）。

#### 介绍

#### 结构

#### 特性

#### 功能

##### 获取本地目录

##### 对文件进行分块

##### 与服务器交换碎片

##### 响应服务器删除本地文件

TODO-yzy：客户端是不是也要实现纠删码？

### 服务器

#### 介绍

#### 结构

#### 特性

#### 功能

##### 接收、回复、转发服务请求与控制信息

##### 转发数据

##### 分离数据链接与控制链接

//TODO

##### 维护文件索引

##### 维护各个客户端的状态信息

TODO-yzy：在线情况、剩余空间、控制TCP链接的线程的编号、（维护token？）

##### 记录、处理当前等待响应的文件请求

### 浏览器端

网页和 web 服务器以及 web 应用程序三者的交互

#### 网页使用 JavaScript

#### 使用 JavaScript 时包含 JQuery 库

#### 网页 UI 设计采用 Bootstrap 框架

#### 网页和服务器的交互采用 AJAX

#### 通讯格式

#### Apache+Tomcat+Servlet+Java Web 应用

#### 动态网页设计

### 纠删码

#### 介绍

#### GitHub 上现有的项目

//TODO

### WebAssembly

//TODO

### 容器化

//TODO

### 虚拟局域网

//TODO

## 理论依据与技术依据

TODO-yzy：在开头简单罗列一下实现的技术

#### 用 Vandermonde Code 编码及解码文件

TODO-yzy：太长酌情删

EC 的定义：Erasure Code 是一种编码技术，它可以将 n 份原始数据，增加 m 份数据，并能通过 n+m 份中的任意 n 份数据，还原为原始数据。即如果有任意小于等于 m 份的数据失效，仍然能通过剩下的数据还原出来。

目前，纠删码技术在分布式存储系统中的应用主要有三类，阵列纠删码(Array Code: RAID5、RAID6等)、RS(Reed-Solomon)里德-所罗门类纠删码和 LDPC(LowDensity Parity Check Code)低密度奇偶校验纠删码。

以下介绍 **Reed-Solomon Code**

RS code 是基于有限域的一种编码算法，有限域又称为 Galois Field，是以法国著名数学家伽罗华（Galois）命名的，在RS code中使用GF(2^w)，其中 2^w >= n + m。

RS code 的编解码定义如下：  

编码：给定n个数据块（Data block）D1、D2……Dn，和一个正整数 m，RS 根据 n 个数据块生成 m 个编码块（Code block），C1、C2……Cm。

解码：对于任意的 n 和 m，从 n 个原始数据块和 m 个编码块中任取 n 块就能解码出原始数据，即 RS 最多容忍 m 个数据块或者编码块同时丢失。

RS 编解码中涉及到矩阵求逆，采用高斯消元法，需要进行实数加减乘除四则运算，无法作用于字长为 w 的二进制数据。为了解决这个问题， RS 采用伽罗华群 GF（2^w）中定义的四则运算法则。

GF(2^w）域有2^w个值， 每个值都对应一个低于 w 次的多项式， 这样域上的四则运算就转换为多项式空间的运算。  GF(2^w)域中的加法就是 XOR， 乘法通过查表实现，需要维护两个大小为 2^w -1 的表格: log表gflog，反log表gfilog。

乘法公式：`a * b = gfilog(gflog(a) + fglog(b)) % (2^w -1)`

##### RS code编码原理

RS 编码以 word 为编码和解码单位，大的数据块拆分到字长为 w（取值一般为 8 或者 16 位）的 word，然后对 word 进行编解码。 数据块的编码原理与 word 编码原理相同，后文中一 word 为例说明，变量 Di, Ci 将代表一个 word。

把输入数据视为向量D=(D1，D2，..., Dn）, 编码后数据视为向量（D1, D2,..., Dn, C1, C2,.., Cm)，RS编码可视为如下图所示矩阵运算。

![img](https://img-blog.csdn.net/20170123112152507)

上图最左边是编码矩阵（或称为生成矩阵、分布矩阵，Distribution Matrix），编码矩阵需要满足任意 n*n 子矩阵可逆。

为方便数据存储，编码矩阵上部是单位阵（n*n），下部是 m 行 n 列矩阵。下部矩阵可以选择范德蒙德矩阵或柯西矩阵。

##### RS code 编码数据恢复原理

RS 最多能容忍 m 个数据块被删除。 数据恢复的过程如下：

（1）假设 D1、D4、C2 丢失，从编码矩阵中删掉丢失的数据块/编码块对应的行。

![img](https://img-blog.csdn.net/20170123112157824)

根据图 1 所示 RS 编码运算等式，可以得到如下 B' 以及等式。

![img](https://img-blog.csdn.net/20170123112206664)

（2）由于B' 是可逆的，记B'的逆矩阵为 (B'^-1)，则B' * (B'^-1) = I 单位矩阵。两边左乘B' 逆矩阵。

![img](https://img-blog.csdn.net/20170123112217304)

（3）得到如下原始数据D的计算公式 

![img](https://img-blog.csdn.net/20170123112224699)

即恢复原始数据D：

![img](https://img-blog.csdn.net/20170123112229074)

（4）对 D 重新编码，可得到丢失的编码码

##### RS code 编码的限制

- 数据恢复代价高和数据更新代价高，因此常常针对只读数据，或者冷数据。
- RS编码依赖于两张 2^w-1 大小的 log 表， 通常只能采用 16 位或者 8 位字长，不能充分利用 64 位服务器的计算能力， 具体实现上可能要做一些优化。

##### 编码矩阵基于范德蒙德（Vandermonde）矩阵

在线性代数中有一种矩阵称为范德蒙德矩阵，它的任意的子方阵均为可逆方阵。一个m行n列的范德蒙德矩阵定义如下，其中Ai 均不相同，且不为0。

![img](https://img-blog.csdn.net/20170123112233523)

令A1、A2...An分别为1、2、3...n，则得到范德蒙德矩阵为：

![img](https://img-blog.csdn.net/20170123112237809)

编码矩阵就是单位矩阵和范德蒙德矩阵的组合。输入数据（D）和编码矩阵的乘积就是编码后的数据。

![img](https://img-blog.csdn.net/20170123112243449)

采用这种方法的算法复杂度还是比较高的，编码复杂度为 O（mn），其中 m 为校验数据个数，n 为输入数据个数。解码复杂度为 O（n^3）。

##### 编码矩阵基于柯西（Cauchy）矩阵

柯西矩阵的任意一个子方阵都是奇异矩阵，存在逆矩阵。而且柯西矩阵在迦罗华域上的求逆运算，可以在 O（n^2）的运算复杂度内完成。

使用柯西矩阵，比范德蒙德矩阵的优化主要有两点：

1）降低了矩阵求逆的运算复杂度。范德蒙矩阵求逆运算的复杂度为 O（n^3），而柯西矩阵求逆运算的复杂度仅为 O（n^2）。

2）通过有限域转换，将 GF（2^w）域中的元素转换成二进制矩阵，将乘法转换为逻辑与，降低了乘法运算复杂度。（二进制的加法即 XOR，乘法即 AND）

柯西矩阵的描述如下：

![img](https://img-blog.csdn.net/20170123112248262)

Xi 和 Yi 都是迦罗华域 GF（2^w）中的元素。

基于柯西矩阵的编码矩阵：

![img](https://img-blog.csdn.net/20170123112252336)

柯西编解码过程优化：

在范德蒙编码的时候，我们可以采用对数/反对数表的方法，将乘法运算转换成了加法运算，并且在迦罗华域中，加法运算转换成了 XOR 运算。

柯西编解码为了降低乘法复杂度，采用了有限域上的元素都可以使用二进制矩阵表示的原理，将乘法运算转换成了迦罗华域“AND 运算”和“XOR 逻辑运算”，提高了编解码效率。

从数学的角度来看，在迦罗华有限域中，任何一个 GF（2^w）域上的元素都可以映射到 GF（2）二进制域，并且采用一个二进制矩阵的方式表示 GF（2^w）中的元素。

例如，GF（2^3）域中的元素可以表示成 GF（2）域中的二进制矩阵：

![img](https://img-blog.csdn.net/20170123112257540)

上图中，黑色方块表示逻辑1，白色方块表示逻辑0。通过这种转换，GF（2^w）域中的阵列就可以转换成GF（2）域中的二进制阵列。生成矩阵的阵列转换表示如下：

![img](https://img-blog.csdn.net/20170123112303415)

在 GF（2^w）域中的编码矩阵为 K*（K+m），转换到 GF（2）域中，使用二进制矩阵表示，编码矩阵变成了 wk* w(k+m)二进制矩阵。

采用域转换的目的是简化 GF（2^w）域中的乘法运算。在 GF（2）域中，乘法运算变成了逻辑与运算，加法运算变成了 XOR 运算，可以大大降低运算复杂度。

和范德蒙编解码中提到的对数/反对数方法相比，这种方法不需要构建对数/反对数表，可以支持 w 为很大的 GF 域空间。采用这种有限域转换的方法之后，柯西编码运算可以表示如下：

![img](https://img-blog.csdn.net/20170123112308352)

算法复杂度：

使用柯西矩阵要优于范德蒙德矩阵的方法，柯西矩阵的运算复杂度为 O(n *(n - m))，解码复杂度为 O(n^2)。

参数 w 影响：

选择 GF(2^w)中的 w 参数是，需要满足 k+n <= 2^w。

### JVM

Java Virtual Machine 是一个虚构出来的计算机，是 Java 程序跨平台的关键。一般语言如果要在不同的平台上运行需编译成对应的目标机器码，而 jre 给 Java 编译出来的字节码以系统相关接口，使得 Java 字节码程序可以在多种平台上不加修改地运行。

## 创新点

TODO-yzy：我们调研报告的“创新点”内容与前人组的这一块有重合，在可行性报告里可以做一些修改让它精简或者更专业。

在我们的设计中，所有部署了客户端的机器成为存储节点共同存储空间存储文件碎片，一个专用的中央服务器维护系统的状态，对文件系统的访问采用 web 前端。这样，只要是一个部署了客户端的机器就可以通过贡献存储空间的方式加入分布式文件系统；只要是一个可以通过网页浏览器访问互联网的设备就都可以访问我们的分布式文件系统。这使得我们的分布式文件系统具备较为便捷的访问方式与利用闲置设备的潜力。

同时，服务器端采用容器化技术进行封装，使得部署相当便捷。存储节点客户端采用 java 实现跨平台，使得贡献存储空间的机器不受限于 linux。文件访问前端基于 web，利用了 web 的高兼容性。

此外，本项目想要实现的分布式文件系统还将做到多用户权限支持、更高效的文件碎片传输、减轻中央服务器负担、提高文件安全性和可用性等优化。

### 备份机制：Erasure Code

### 可用性：结合对等主机与网盘服务

### 用户访问

用户要很容易访问网盘，故选择网页前端展示、js 脚本处理文件。系统还提供 API 接口，以可开发对应的客户端，方便使用。

### 客户端部署

客户端由 Java 语言开发，可在任何装有 jre 环境的计算机里运行。

### 容器化部署服务端

软件开发最大的麻烦事之一就是环境配置，而一个可用软件的交付过程通常包含两个部分：开发、维护。而我们很难保证软件开发测试和运行维护阶段的软件能运行在一模一样的环境下，很多时候我们都要花大量的时间去配置环境。例如参考项目中，中央服务器需要配置 apache+tomcat+mysql+java 环境，这要求使用者有一定配置 linux 服务器的知识。

本项目将采用 docker 容器化技术，方便服务器端的部署，从而降低网盘使用门槛，增强用户体验，实现私人网盘的易用性。

### 跨平台

存储节点的设备五花八门，客户端需要容易实现跨平台以最大程度地利用碎片化的设备存储，故采用 java 语言编写存储节点客户端程序。同时用户要很容易访问网盘，故选择 web 前端展示、js 处理文件。

### erasure code 冗余备份

纠删码（erasure code）相比直接副本备份节约存储空间，同样也起到了保护数据不易丢失的作用。

### 加入多用户权限支持

出于增加可用节点数量，增加可用存储空间大小和提供分享文件的便利的考虑，小型分布式文件系统需要支持多个用户的使用。

出于安全考虑，关键的的功能需限制部分用户的使用；出于方便性考虑，系统功能也需要根据不同的用户而定制，如下图示，多用户权限管理系统十分重要：

<img src="files/research-mu.png" alt="1" style="zoom:50%;" />

而参考项目虽然实现了注册和登录等相关功能，但对于用户的权限并没有作出区分，所有用户共享同一个上传/下载目录。虽然共享文件时非常方便，但是缺失了个人独立的存储空间。本项目将对此做出改变，提供一个兼具隔离与共享的分布式文件系统。

### 更高效的文件处理和传输

参考项目对于文件编解码、分割、传输的具体实现如下：

上传（目前仅有存储节点客户端的实现）：

- 存储节点客户端文件分块模块对文件应用 erasure code 算法进行分块
- 存储节点客户端与服务器建立连接并将碎片发往服务器
- 服务器暂存碎片
- 服务器将碎片分发给各存储节点，发送完碎片后服务器将暂存的碎片删除

下载：

- 浏览器端请求文件
- 中央服务器向各存储节点收集该文件的碎片
- 中央服务器拼接成完整文件
- 浏览器下载完整文件

上述实现中，文件的分块处理和分发都是中央服务器提供的服务，这样一来中央服务器的负载较重，且没有很好地利用多个存储节点和浏览节点之间的带宽。而更高效的实现应该是将编解码以及切分文件等工作转移到浏览器端实现，并且将文件传输的数据连接分离出来，直接在存储节点和浏览节点之间建立连接。

### 提高文件安全性

当“私有网盘”的服务范围从个人扩展到一个小群体时，存储设备和文件是所有者将不再是同一个人，从而产生了数据隐私的担忧。设备持有者只要设法收集足量的碎片即可还原出属于其他用户的文件，上传文件的安全性将受到威胁。

对文件先加密后存储可以很好地解决这一问题。参考项目并没有处理加密的问题，本项目将在安全性方面进行优化。

### 提高服务可用性

作为一个“私人网盘”服务，很难保证各存储节点的长期在线。即使存储时进行了冗余处理，设备离线率较高时依然不能保证文件的获取。

通过设备历史在线状态优化上传文件时分配碎片的策略（例如分配给在线率高的节点较多碎片），有助于提高服务的可用性。

## #附录 1 相关调研

## 相关工作（科研及工业界）

TODO-yzy：感觉相关工作应该拆散到各个小点可行性里面介绍，如果这样的话调研报告里的这一块可以删掉

## 参考文献

